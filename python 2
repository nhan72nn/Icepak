import csv
import xml.etree.ElementTree as ET

def mm_to_m(val):
    return float(val) / 1000.0

def create_ecxml_from_csv(csv_path, output_path):
    neutralXML = ET.Element("neutralXML")
    ET.SubElement(neutralXML, "name").text = "dfsi units W/m2"
    ET.SubElement(neutralXML, "producer").text = "Icepak"

    solutionDomain = ET.SubElement(neutralXML, "solutionDomain")
    loc = ET.SubElement(solutionDomain, "location")
    ET.SubElement(loc, "x").text = "0.0"
    ET.SubElement(loc, "y").text = "0.0"
    ET.SubElement(loc, "z").text = "0.01087"
    size = ET.SubElement(solutionDomain, "size")
    ET.SubElement(size, "x").text = "0.2"
    ET.SubElement(size, "y").text = "0.2"
    ET.SubElement(size, "z").text = "6.93889e-18"

    ET.SubElement(neutralXML, "materials")

    geometry = ET.SubElement(neutralXML, "geometry")
    assembly = ET.SubElement(geometry, "assembly")
    ET.SubElement(assembly, "name").text = "G-die-generated"
    ET.SubElement(assembly, "active").text = "true"
    geom = ET.SubElement(assembly, "geometry")

    with open(csv_path, newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            if len(row) < 7:
                continue  # Skip incomplete rows

            name, x1, y1, x2, y2, z, power = row
            x1 = mm_to_m(x1)
            y1 = mm_to_m(y1)
            x2 = mm_to_m(x2)
            y2 = mm_to_m(y2)
            z = mm_to_m(z)
            power = float(power)

            block = ET.SubElement(geom, "source2dBlock")
            ET.SubElement(block, "name").text = name
            ET.SubElement(block, "active").text = "true"

            location = ET.SubElement(block, "location")
            ET.SubElement(location, "x").text = f"{(x1 + x2) / 2:.6f}"
            ET.SubElement(location, "y").text = f"{(y1 + y2) / 2:.6f}"
            ET.SubElement(location, "z").text = f"{z:.6f}"

            size = ET.SubElement(block, "size")
            ET.SubElement(size, "x").text = f"{abs(x2 - x1):.6f}"
            ET.SubElement(size, "y").text = f"{abs(y2 - y1):.6f}"
            ET.SubElement(size, "z").text = "0.001"

            ET.SubElement(block, "plane").text = "+xy"
            ET.SubElement(block, "powerDissipation").text = f"{power:.6f}"

    tree = ET.ElementTree(neutralXML)
    tree.write(output_path, encoding="utf-8", xml_declaration=True)

# Example usage:
# create_ecxml_from_csv("input.csv", "output.ecxml")




import pyvisa
import time
import csv
from datetime import datetime

# === CONFIGURATION ===
VISA_ADDRESS = 'USB0::0x049F::0xA018::MY12345678::INSTR'  # replace with your instrument’s VISA ID
TEMP_CH_RANGE = '(@1:10)'
VOLT_CH_RANGE = '(@11:20)'
INTERVAL_SEC = 5
CSV_FILENAME = 'fluke1586a_log.csv'
TXT_FILENAME = 'fluke1586a_log.txt'

def setup_instrument(rm):
    inst = rm.open_resource(VISA_ADDRESS)
    inst.timeout = 5000  # ms
    
    # Reset and clear
    inst.write('*RST')
    inst.write('*CLS')
    
    # Configure channels 1–10 as Type T thermocouples
    inst.write(f'CONF:TEMP TC,T{TEMP_CH_RANGE}')
    
    # Configure channels 11–20 as DC volts (auto range)
    inst.write(f'CONF:VOLT:DC AUTO{VOLT_CH_RANGE}')
    
    # Turn on data buffering if desired (optional)
    # inst.write('BUFON')
    
    return inst

def main():
    rm = pyvisa.ResourceManager()
    inst = setup_instrument(rm)
    
    # Prepare CSV file with header if not exists
    header = ['timestamp', 'unix_time'] + \
             [f'T{ch}' for ch in range(1, 11)] + \
             [f'V{ch}' for ch in range(11, 21)]
    try:
        with open(CSV_FILENAME, 'x', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(header)
    except FileExistsError:
        pass  # already exists
    
    print(f"Logging to {CSV_FILENAME} and {TXT_FILENAME}. Press Ctrl+C to stop.")
    
    try:
        while True:
            # Human-readable and Unix timestamp
            now = datetime.now()
            ts_str = now.strftime('%Y-%m-%d %H:%M:%S')
            unix_ts = f"{now.timestamp():.3f}"
            
            # Trigger a single-shot read of all channels
            # This assumes the instrument supports a combined query
            # Otherwise you can query TEMP and VOLT separately
            raw = inst.query(f'FETC? {TEMP_CH_RANGE},{VOLT_CH_RANGE}')
            # raw comes back like: "+23.123,+23.456,...,+0.0012,+0.0013,..."
            values = [v.strip() for v in raw.split(',')]
            
            # Compose row
            row = [ts_str, unix_ts] + values
            
            # Append to CSV
            with open(CSV_FILENAME, 'a', newline='') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(row)
            
            # Append to TXT
            with open(TXT_FILENAME, 'a') as txtfile:
                txtfile.write('\t'.join(row) + '\n')
            
            # Wait
            time.sleep(INTERVAL_SEC)
    
    except KeyboardInterrupt:
        print("\nMeasurement stopped by user.")
    finally:
        inst.close()
        rm.close()

if __name__ == '__main__':
    main()
